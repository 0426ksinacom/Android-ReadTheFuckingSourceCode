# Java 基础知识

### OOP 的概念

面向对象编程是使用类，对象，继承性，多态性，封装性和抽象的一种程序设计方法。

首先我们要区分一下“基于对象”和“面向对象”的区别。

1. 基于对象，通常指的是对数据的封装，以及提供一组方法对封装过的数据操作。
2. 面向对象，则在基于对象的基础上增加了多态性。所谓多态，就是可以用统一的方法对不同的对象进行同样的操作。

### 面向对象的三个基本元素和五个原则

- 三个基本元素：

1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。
2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。
3. 多态： 多态性是指允许不同类的对象对同一消息作出响应。

- 五个基本原则：

1. 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。

2. 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。

3. Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

4. 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

5. 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口。

### 接口（Interface）与抽象类（Abstract Class）的区别

- 抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。
- 接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。

### 覆盖（Overriding）与重载（OverLoading）的区别

1. 覆盖是子类与父类之间的关系，是一种垂直关系；重载是同一个类中方法之间的关系，是水平关系
2. 覆盖只能由一个方法或者只能由一对方法产生关系；重载是多个方法之间的关系
3. 覆盖要求参数列表要相同；重载要求参数列表不同
4. 覆盖关系中，调用方法体是根据对象的类型（对象对应存储空间类型）决定，重载是根据调用的时候实参表和形参表来选择方法

### 序列化是什么？如何实现它？

序列化是一种将对象转换为字节流的过程，目的是为了将该对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态及数据信息。

Java中，有两种方式可以实现序列化，既可以实现Serializable接口，也可以实现Parcelable接口。然而，在Android中，我们不应该使用Serializable接口。因为Serializable接口使用了反射机制，这个过程相对缓慢，而且往往会产生出很多临时对象，这样可能会触发垃圾回收器频繁地进行垃圾回收。相比而言，Parcelable接口比Serializable接口效率更高，性能方面要高出10x多倍。

### 什么是单例？

单例模式指的是一个类只能被初始化一次，即只有一个实例。单例模式限定一个类只能拥有一个实例。这在系统中只需要一个实例来和其他模块协调工作时是很实用的。单例普遍使用在只需要一个或是限制一定数量实例的系统中。

### 什么是匿名内部类？

普通的类可以自然地实例化他自己，相反地，内部类是这样的类： 一定要绑定上一个外部类才能进行实例化的类。而匿名内部类也就是没有名字的内部类，因为没有名字，所以只能使用一次。使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

### 对字符串进行 == 和 equals() 操作时有什么区别？

== 比较两个字符串的地址，初学者很经常拿来比较其内容，将会导致出现不等的情况。 equals()是String这个类重写的一个方法，平常的类的equals()也仅仅是比较两个变量的地址，而String类的equals()重写后，将依次比较其串中的字符。

### hashCode() 和 equals() 何时使用？

一般是在想要人性化地（而不是计算机式地,比较地址那样）比较两个对象的时候，我们需要使用这两个方法，或者说我们要重写这两个方法，而且有如下的原则：

1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2. 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

### Java 中的 final, finally 和 finalize？

1. final: 修饰变量，方法，类； 修饰变量时表明这对象的值不可变，你不能为这个变量赋一个新的值，或者这样说：对基本类型而言，你不能改变其数值，对于引用，你不能将其指向一个新的引用（而引用自身是可以改变的）。 修饰方法时表明我们希望把这个方法锁定，以防止任何继承类修改它的含义，这样会确保在继承中，我们的 final 方法的行为不会改变，并且不会被覆盖。使用 final 方法的另一个考虑是效率问题：在 Java 早期的时候，遇到 final 方法，编译器会将此方法调用转为内嵌调用，如此一来以减小方法调用产生的开销。 修饰类的时候表明你不打算继承该类，而且也不允许别人这样做。
2. finally: 是异常处理中进行收场处理的代码块，比如关闭一个数据库连接，清理一些资源占用的问题。不管有没有异常被捕获，finally子句中的代码都会被执行。
3. finalize: finalize出现的原因在于，我们一定需要进行清理动作。Java 没有用于释放对象的，如同 C++ 里的 delete 调用，的方法，而是使用垃圾回收器（GC）帮助我们释放空间。当垃圾回收器准备释放对象占用的存储空间的时候，将首先调用其 finalize()方法。

### 比较 Arrays 和 ArrayList

Arrays：一个包含许多和操纵数组有关方法的类，比如排序和查找，它继承自 Object 类。
ArraysList：是一个容器，它可以实现数组的大小可变，方便地增加和删除元素。它实现了 List 接口的类。

### 比较 HashSet 和 TreeSet

TreeSet是基于二叉树实现的，其中的数据是自动排序好的。不允许放入null值。
HashSet是基于Hash表实现的，其中的数据是无序的，允许放入null值。

### Java 中 static 关键字是什么意思？

static 是 Java 里的非访问修饰符，它可以用来创建类方法和类变量。

当修饰一个变量的时候，此变量就成了独立于对象的静态变量，无论一个类实例化了多少个对象，这个类只有一份这个静态变量的拷贝，所以 static 修饰的变量，即静态变量，也被叫做类变量。一个局部变量不能被声明为 static 变量。

当修饰一个方法的时候，此方法就成了独立于对象的静态方法，静态方法不能使用类的非静态变量，因为静态方法和静态变量先于非静态的其他成员初始化，静态方法先出来，然后才是非静态的，所以明白这个顺序很重要。静态方法从参数列表得到数据，然后计算这些数据。

### Java 中静态方法可以被重写吗？

严格来说，不存在静态方法的重写，当一个子类继承父类时，写同样的方法时，只是将父类的静态方法隐藏。

### Integer 和 int 之间的区别

1. Integer 是 int 提供的封装类，而 int 是 Java 的基本数据类型； Integer 默认值是 null，而 int 默认值是0； 声明为 Integer 的变量需要实例化，而声明为 int 的变量不需要实例化； Integer 是对象，用一个引用指向这个对象，而 int 是基本类型，直接存储数值
2. 两个 new 出来的 Integer总 是不一样的。当使用 == 时，发现其内存地址不同，所以进行 == 返回 false
3. 两个不是 new 出来的 Integer，而是诸如 Integer i = x，如果 x 的范围在 -128～127，因为如下语句： Integer i5 = 127;//java 在编译的时候，被翻译成 -> Integer i5 = Integer.valueOf(127); 调用了 Integer.valueOf()， 这会将 127 缓存，下次我们写：Integer i6 = 127; 时，i6 指向缓存中的同一个对象。所以此时 i5==i6 是 true； 当 x 范围在 -128～127 之外，没有缓存存在，即使他们包裹的数值相等，他们也不能使用 == 的到 true。
4. int 和 Integer 的比较，无论 Integer 是否使用 new，其值和将和平常的预料的一样: Integer 自动拆箱，然后和 int 比较数值。这里就不会被内存地址的不同所影响，该相等时就相等。

### 在 Java 中什么是强引用、软引用、弱引用以及虚引用？

强引用：不会被GC轻易清理，只要引用存在，垃圾回收器永远不会回收。
```Java
Object obj = new Object();
```

软引用： 非必须引用，内存溢出之前进行回收
```Java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
```

弱引用： 第二次垃圾回收时回收
```Java 
Object obj = new Object(); 
WeakReference wf = new WeakReference(obj); 
obj = null; wf.get();//有时候会返回null 
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```

虚引用： 垃圾回收时回收，无法通过引用取到对象值
```Java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```

### 关键字 synchronized 的作用是什么？

synchronized 通过修饰一个方法或者代码块，从而产生一个同步对象锁，以及对应的同步代码块。每当有线程要对该同步代码块进行访问时，线程就会首先尝试获取这个对象的锁，并在成功获取到对象锁后，对这个同步代码块进行正常的访问。在同步代码块的访问过程中，线程会一直持有这个对象锁，直到同步代码块访问完毕，然后才会释放。

在上述线程持有同步锁并进行同步代码块访问过程中，其它线程将无法获得该对象锁，也无法访问该同步代码，这些线程都会被阻塞直到上述线程访问完毕。

### 修饰符 transient 和 volatile 的作用是什么？

volatile：易式修饰符

出现它的原因是，java 的多线程中存在两个或多个线程时间间隔很短地访问共享成员变量（指被多个线程共享的变量），在每个线程自己的工作内存中，可能对这个变量进行修改，但是没有及时将工作内存中的变量（对原本的共享成员变量的一份拷贝）写回共享成员变量，此时，当另外一个线程进行读取时，将无法得到最新的此变量，导致进程的工作不能正确进行。

于是出现了volatile，带有 volatile 修饰的变量，就是当其在某个线程自己的工作内存中发生改变时，会被强制地，写回公共成员变量所在的公共内存处。

如此便保证了，所有线程对这个变量的访问都是能得到此变量最新状态的访问。

transient：
transient是一个类型修饰符，仅仅能用来修饰字段（变量）。在此字段所在的对象进行序列化的时候，这个字段不会被序列化。

其他没有 transient 修饰的变量将会被序列化，然后进行传输，或者存储到本地磁盘，transient 变量就在这个过程里丢失了。

### StringBuffer 和 StringBuilder 的区别在哪里？

StringBuffer、StringBuilder 和 String 一样，也用来代表字符串。String 类是不可变类，任何对 String 的改变都 会引发新的 String 对象的生成；StringBuffer 和StringBuilder 则是可变类。

先说一下，以集合为例，HashTable 是线程安全的，很多方法都是 synchronized 方法，而 HashMap 不是线程安全的，但其在单线程程序中的性能比 HashTable 要高。StringBuffer 和StringBuilder 类的区别也是如此，他们的原理和操作基本相同，区别在于 StringBuffer 支持并发操作，线性安全的，适合多线程中使用。StringBuilder 不支持并发操作，线性不安全的，不适合多线程中使用。新引入的 StringBuilder 类不是线程安全的，但其在单线程中的性能比 StringBuffer 高。

### Java7，Java8，Java9版本特性

### 简述垃圾回收器的工作原理
Java的垃圾回收机制是Java虚拟机提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间。

- 引用计数器
- 停止-复制
- 标记-清除
- 标记-压缩
- 分代

### String a = "a"+"b"+"c" 在内存中创建几个对象？

这个问题涉及到了字符串常量池和字符串拼接
```Java
String a = "a"+"b"+"c"
```

通过编译器优化后，得到的效果是
```Java
String a = "abc"
```

此时，如果字符串常量池中存在 abc，则该语句并不会创建对象，只是讲字符串常量池中的引用返回而已。

如果字符串常量池中不存在 abc，则会创建并放入字符串常量池，并返回引用，此时会有一个对象进行创建。

两个深入阅读的链接：

- 字符串常量池： http://droidyue.com/blog/2014/12/21/string-literal-pool-in-java/  
- 字符串拼接内部实现：http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/



